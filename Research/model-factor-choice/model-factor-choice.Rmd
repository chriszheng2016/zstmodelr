---
title: "研究分析：有效因子筛选识别"
documentclass: ctexart
geometry:
  - tmargin=2cm
  - bmargin=2cm
  - lmargin=2cm
  - rmargin=2cm
editor_options:
  chunk_output_type: inline
output:
  html_document:
    fig_caption: yes
    number_sections: yes
    toc: yes
    toc_depth: 4
  html_notebook:
    fig_caption: yes
    number_sections: yes
    toc: yes
    toc_depth: 4
  rticles::ctex:
    fig_caption: yes
    number_sections: yes
    toc: yes
    toc_depth: 4
  pdf_document:
    toc: yes
    toc_depth: 4
  word_document:
    fig_caption: yes
    toc: yes
    toc_depth: 4
params:
  
  test_start_date:
    label: 'test start date:'
    input: date
    value: '2016-01-01'
      
  test_end_date:
    label: 'test end date:'
    input: date
    value: '2017-12-31'
    
  factors_list:
    choices:
    - GPM
    - ROCE
    - PE
    - PB
    - CUR
    - QR
    input: select
    label: factors list
    multiple: yes
    value:
    - GPM
    - ROCE
  test_stkcds:
    label: 'target stkcds:'
    input: text
    value: '600031, 000157, 600066, 000550'
    
classoption: hyperref,
---


```{r setup, include=FALSE  }

library(fPortfolio)
library(PerformanceAnalytics)
library(tidyverse)
library(lubridate)
library(stringr)
library(shiny)
library(zstmodelr)


# Set global options for knitr
knitr::opts_chunk$set(
  comment = "#>",
  echo = FALSE,
  warning = FALSE,
  message = FALSE,
  collapse = TRUE,
  fig.align = "center",
  fig.show = "hold",
  out.width = "80%",
  tidy = TRUE
)

options(tibble.print_min = 10L, tibble.print_max = 20L)

# options(digits = 3)
```

# 研究工作概要

  在因子原始数据采集和计算基础，针对目标因子进行评估筛选，以初步识别有效的因子。 主要工作包括：
  
  * **数据规范化(Normalization)**
  
    由于原始数据的量纲不一致，为保证数据之间的可比性和可叠加性，要对原始数据进行标准化、去量纲的工作。

  * **因子有效性评估**
  
    原始因子集合是在逻辑上被认为与股票收益率存在关联性的因素，实证中并不是每个原始因子和股票收益率都存在相关性，因此需要对原始因子进行有效性检验，排除跟收益率相关性不高的因子。

# 数据准备(Data Preparation)


## 研究参数设置(Study Params)
```{r set_params}

# Target factors list
# target_factors_list <- c("GPM", "ROCE", "PE", "PB", "CUR", "QR")
target_factors_list <- params$factors_list

# Test stocks list
if (params$test_stkcds != 'all') {
  test_stkcds <- stringr::str_split(params$test_stkcds, pattern = ",")
  test_stkcds <- stringr::str_trim(unlist(test_stkcds))
} else {
  test_stkcds <- NULL
}

# period of test
start_date <- params$test_start_date
end_date <- params$test_end_date

```

主要评估参数如下：

* **评估因子:** `r params$factors_list`

* **回溯期间:** `r params$test_start_date` ~ `r params$test_end_date`

* **股票池:** 全A股及创业板，剔除ST、PT股票，剔除每个截面期一下交易日停牌的股票。


```{r fetch_factors_data, cache=FALSE, cache.extra = list(params$test_start_date, params$test_end_date, params$factors_list, params$test_stkcds)}

# Open gta stock databse
stock_db <- stock_db(gta_db, "GTA_SQLData")
open_stock_db(stock_db)

# Initate the stock database
invisible(init_stock_db(stock_db))

# Limit test_stock to A stocks and Growth stocks
ds_test_stock_info <- get_stock_info(stock_db, 
                                     stock_cd_list = test_stkcds)
ds_test_stock_info <- ds_test_stock_info %>%
  dplyr::filter(market_type %in% c("SH_A", "SZ_A", "SZ_G"))
test_stkcds <- ds_test_stock_info$stkcd

# Get factors info
factors_info <- get_factors_info(stock_db, factor_groups = NULL)

# Get fundamental indicators
fundamental_factors_raw <- get_factors(stock_db,
  factor_codes = target_factors_list
)

# Filter factors for target stocks
if (!is.null(test_stkcds)) {
  fundamental_factors_raw <- fundamental_factors_raw %>%
    dplyr::filter(stkcd %in% test_stkcds)
}

# Filter factors in specified dates
fundamental_factors_raw <- fundamental_factors_raw %>%
    dplyr::filter(date >= start_date & date <= end_date) %>%
    dplyr::arrange(stkcd, date)

# Convert to long format to wide format
if (all(c("factor_name","factor_value") %in% names(fundamental_factors_raw))) {
  fundamental_factors_raw <- fundamental_factors_raw %>%
   tidyr::spread(key = "factor_name", value = "factor_value")
}

# Notice: add attribute only work for wide format.
# Add industry code attribute to factors
if (!("indcd" %in% names(fundamental_factors_raw))) {
  fundamental_factors_raw <- attr_indictors_indcd(stock_db,
    fundamental_factors_raw,
    parallel = TRUE
  )
}

# Add trading status atttribute to factors
if (!("trdstat" %in% names(fundamental_factors_raw))) {
  fundamental_factors_raw <- attr_indictors_trdstat(stock_db,
    fundamental_factors_raw,
    parallel = TRUE
  )
}

# Filter factors only for list stocks
fundamental_factors <- fundamental_factors_raw %>%
  dplyr::filter(trdstat == "list") %>%
  dplyr::select(-trdstat)

# Get stocks return
stocks_return_raw <- get_stock_return(stock_db,
  stock_cd_list = test_stkcds,
  period_type = "month",
  period_date = "end",
  output_type = "tibble"
)

# Filter stocks return in specified dates
stocks_return <- stocks_return_raw %>%
    dplyr::filter(date >= start_date & date <= end_date)

```

## 目标因子概要(Target Factor Summary)

因子主要是指基本面因素，按投资风险的风格分类，分为如下**类别(Style Factors)**:
   
* **估值因子(Valuation Factors)：**

    用于衡量股票价格是否相对偏高或偏低，因素值较大的公司，意味公司股票可能被高估或具有较高的未来成长性。

* **清偿能力因子(Solvency Factors)：**

    用于衡量一个公司不同类别的流动资金偿还负债的能力。清偿能力因素值较大的公司具有更好的资金流动性或清偿债务的能力，并且较少受到于由支付债务和其它负债而破产的威胁。

* **营运效率因子(Operating Efficency Factors)**

    用于描述公司对短期和长期资产的运营绩效。因素值较大的公司，比较充分地利用了资产。

* **营运盈利能力因子(Operating Profitability Factors)**

    用于衡量公司获取利润的能力。因素值较大的公司，具有较强的竞争能力，可获得较好的较高的利润。

* **财务风险因子(Finacial Risk Factors)**

    用于衡量公司可能面临破产的风险，即对应对销售暂时放缓或突遇经济时，公司能会较大  的利润波动和面临较高的财务压力，以至于导致破产。

* **流动性风险因子(Liquidity Factors)**

    用于衡量股票交易的难易程度。

* **技术因子(Technical Factors)**
  
    用于捕捉股票相对价格的短期波动。


   本次评估目标因子如下：
```{r factor_info}

# Display target factors information
target_factors_info <- factors_info %>%
  dplyr::filter(factor_code %in% target_factors_list)

knitr::kable(
  target_factors_info,
  format = "pandoc",
  align = "c",
  digits = 3,
  caption = "目标因子信息"
)
```



## 因子数据规范化(Factors Normalization)

由于各因子的量纳不同，为方便比较和回归，需要对因子进行规范化处理，主要分为
两步：

* **第一步、剔除异常极值**

  由于少数异极值对因子和收益率之间相关系数估计造成严重干扰，故需要对异常极值进行处理，处理方式包括：保留极值、用边界值替换、删除极值。
  
  判断异常极值方法主要有：
  
  - **均值标准差法**
  
    这种想法的思路来自于正态分布, 假设$X\sim N(\mu,\sigma^{2})$, 则
  
  $$P(|X-\mu| > k*\sigma  =\begin{cases}
      0.317 & k=1\\
      0.046 & k=2\\
      0.03 & k=3
  \end{cases})$$
  
  通常把偏离均值**三倍标准差**以外的数据作为异常值数据。
  
  不过要注意的是样本均值和样本标准差都不是稳健统计量，其计算本身受极值的影响就非常大，所以可能会出现一种情况，那就是我们从数据分布图上能非常明显的看到异常点，但按照上面的计算方法，这个异常点可能仍在均值三倍标准差的范围内。因此按照这种方法剔除掉异常值后，需要重新观察数据的分布情况，看是否仍然存在显著异常点，若存在则继续重复上述步骤寻找异常点。

  在样本数据不符合正态分布的情况下，根据Chebyshev不等式，我们仍然可以对均值三倍标准差外的样本数据数量占比做出估计：
  $$P(|X-\mu|\geq k\cdot\sigma)\leq1/k^{2}$$

  但不等式右边的上界数值过于偏大，在数据分布的偏度和峰度影响下，这种方法可能会把过量的数据认定为异常点。
  
  + **中位数去极值法：**
  
    MAD 法是针对均值标准差方法的改进，把均值和标准差替换成稳健统计量，样本均值用样本中位数代替，样本标准差用样本MAD （Median Absolute Deviation）代替：
  $md = median(\{ x_{i},i=1,2,3\cdots n\} )$(相当于mean),$MAD = median(\{|x_{i}-md|, i = 1,2,3\cdots n\})$(相关于std),即：
  
  
  通常把离中值**三倍MAD**以外的数据作为异常值数据。
  
  + **Boxplot法**
  
    TODO

* **第二步、标准化**

  + **直接标准化：**
  
    直接对去极值后因子暴露进行直接进行标准化处理，
  $$\tilde{x}_{i}=\frac{x_{_{i}-\mu}}{\sigma}$$
  $\mu$: 序列$x_{i}$的均值，$\sigma$: 序列$x_{i}$的标准差，$\tilde{x}_{i}$: 序列$x_{i}$标准化后的值。
  
  + **排序标准化**
  
    将去极值原始因子暴露序列转换成序关系序列：$\tilde{x}_{i} = rank({x}_{i})$后，再进行计算标准得分，计算方法同上。
  

* **第三步、缺失值处理**

    得到标准化的因子暴露序列后，将因子暴露缺失的地方设为零（这里解释一下，由于不同因子可能在不同个股处存在缺失值，若不对缺失值进行处理则每个单因子回归的票池并不完全相同，不同单因子回归结果的可比性较差，但如果将所有出现缺失值的个股都从回归票池中剔除，当数据源质量不佳时可能会造成票池大幅减少，回归结果同样不可信，所以这里折中处理，将因子暴露缺失的地方设为新序列的均值，即设为零，可视作当存在缺失值时我们认为此个股的因子值与全市场平均情况相同，即持中性看法）。

本报告中因子数据规范化处理：

- 对采用“均值标准差法”检测异常极端值，对检测异常值用边界值替换；

- 对去除异常值的因子序列采用“直接标准化”.


```{r factors_Normalization, cache=FALSE, autodep= TRUE}

# Normalize the factor indicators
fundamental_normal_factors <- fundamental_factors %>%
  normalize_factors(
    group_by = c("date"),
    clean_extremes_method = "sigma",
    standard_method = "normal"
  )

# Convert factors into specified frequency
fundamental_normal_factors_period <- fundamental_normal_factors %>%
  ts_asfreq(
    freq_rule = "month", fillna_method = "ffill",
    date_index_field = "date", key_fields = "stkcd",
    parallel = TRUE
  )

# Resample return by specified frequency
stocks_return_period <- stocks_return %>%
  # dplyr::filter(date >= start_date & date <= end_date) %>%
  ts_resample(
    freq_rule = "month", fillna_method = "nfill",
    date_index_field = "date", key_fields = "stkcd",
    agg_method = function(x) {
      prod(1 + x, na.rm = TRUE) - 1
    },
    parallel = TRUE
  )

# Lag factors to avoid peeking ahead bias
fundamental_normal_factors_lag_period <- ts_lag(
  fundamental_normal_factors_period,
  k = 3,
  trim = FALSE,
  date_index_field = c("date"),
  key_fields = c("stkcd", "period", "indcd"),
  parallel = TRUE
)


```

## 因子分布状况(Factor Distribution Exploration)

  对规范化后因子数据，计算在每个时间截面的因子分布参数(平均值等)，对计算参数时间序列的平均值，获得分布参数如下：

```{r factor_test_summarize_factors}

# summarize factors distribution
summary_fundamental_normal_factors <- fundamental_normal_factors %>%
  tidyr::gather(
    key = "factor_name", value = "factor_exposure",
    target_factors_list
  ) %>%
  dplyr::group_by(factor_name, date) %>%
  dplyr::summarise_at("factor_exposure",
    funs(
      obs = mean(length(.)),
      nas = sum(is.na(.)),
      mean,
      sd,
      median,
      mad,
      min,
      Q1 = quantile(., 0.25),
      Q3 = quantile(., 0.75),
      max,
      skewness = PerformanceAnalytics::skewness,
      kurtosis = PerformanceAnalytics::kurtosis
    ),
    na.rm = TRUE
  ) %>%
  dplyr::select(-date) %>%
  dplyr::group_by(factor_name) %>%
  dplyr::summarise_all(mean)


knitr::kable(
  summary_fundamental_normal_factors,
  format = "pandoc",
  align = "c",
  digits = 3,
  caption = "因子分布情况总览"
)
```

注意：kurtosis 为超过正态分布峰度的数值。



# 单因子筛选检测(Uinivariate Factors Test)

  按有效性因子分为：

- **收益率因子(alpha因子)**：
  因子对股票的收益率具有显著的且稳定的影响的某些变量，即因子的收益率序列均值显著不为零，且方向明确。对于下一期的因子的收益率预测相对较为准确。

- **风险类因子**：
  因子对于股票收益率的影响并不明显，因子收益率序列的均值在0值附近，正负方向并不明确。


检验单个因子的有效性方法包括：


* **因子截面回归法**

  对单因子的横截面回归方程系数(因子收益)形成序列的平均值进行$t$检验，根据因素收益平均值是否著不为零，来判断因子有效程度。

* **因子信息系数(IC)法**

  对单因子的信息系数序列(Information Coefficients ，因子截面暴露值序列和截面超额收益率序列的相关系数)均值进行$t$检验，根据IC平均值是否显著不为零，来判定因子有效程度，即IC序列均值当显著不为0且超过某一阀值即认定为alpha源。

* **投资组合分类法 **

  根据因子值对股票进行排序后分成N种投资组合，并构建多空组合（具有最高因素值的组合与最低因素值组合之间收益差），对多空组合的收益率的平均值进行$t$检验，根据多空组合平均收益是否显著不为零来判定因子的有效程度。另外，还可对各投资组合使用年化收益率，夏普比率，年化波动率，最大回撤等进行评测。

* **因子组合法**


## 因子截面回归(Factor Test of Barra Univarate Regression)


### 因子评估方法

* **步骤1、单因子回归确定每个因子每期的因子收益**

  在指定时期内的每个时点$t$上进行横截面回归：
  $$r_{i,t} = \beta_{i,t}*f_{t} + \varepsilon_{i,t}, i = 1,2,\cdots,N$$
  获得各横截面上的斜率(因子收益$f_{t}$)和残差($\varepsilon_{i,t}$)所形成的序列。
  
  在截面期上用其做因变量对市值因子及行业子（哑变量）做线性回归，取残差作为因子值的一个替代。这样做可以消除行业因素和市值因素对因子的影响。计算残差序列和T+1期股票收益序列的相关系数作为T期因子IC 值。

* **步骤2、对因子收益率序列进行$t$检验**

  对因子收益序列($f_{t}$)进行$t$检验，判断因子的平均收益的是不显著不为零, 同时统计正值/负值比例，结合平均收益率的正负，判断察因子收益的方向。

### 因子评估结果

因子评估结果字段说明：

* factor_name: 因子名称
* obs: 因子收益序列中样本数；
* nas: 因子收益序列中NA数；
* avg: 因子收益序例样本均值；
* med: 因子收益序例样本中数；
* min: 因子收益序例样本最小值；
* max: 因子收益序例样本最大值；
* std：因子收益序例样本标准差；
* skew: 因子收益序例样本偏度；
* kurt: 因子收益序例样本超额峰度；
* pos_pct: 因子收益序列中正值比例；
* neg_pct: 因子收益序列中负值比例；
* odds: 因子收益序列胜率=正值比例/负值比例； 
* t.test_t: 对因子收益序列均值非零$t$检验的$t$统计量 绝对值大于2时均值显著不为0；
* t.test_p: 对因子收益序列均值非零$t$检验的$p$概率值, 小于0.05时均值显著不为0
* normal.test_p: 正态分布检验(Shapiro-Wilk)$p$概率值，小于0.05时判定因子收益序列非正态分布。 

```{r factor_test_Uniregression_common, cache=FALSE, autodep= TRUE}

# Build test data dataset
ds_test_uniregression <- stocks_return_period %>%
  dplyr::inner_join(fundamental_normal_factors_lag_period, by = c("date", "stkcd")) %>%
  tidyr::gather(-(date:indcd), key = "factor_name", value = "factor_exposure") %>%
  dplyr::select(date, stkcd, indcd, return, factor_name, factor_exposure)


# Model of conducting univariate regression test
model_univariate_crossection_regression <- function(df,
                                                    neutralize = c("non", "industry"),
                                                    ...) {
  # Conduct regression
  neutralize <- match.arg(neutralize)
  switch(neutralize,
    "non" = {
      # Conduct cross-section regression
      regress_result <- lm(return ~ factor_exposure, data = df, ...)
    },
    "industry" = {
      # Remove impact of industry on factor return
      lm_deindustrialize <- lm(return ~ indcd,
        data = df,
        na.action = na.exclude
      )

      # Use residual to conduct regression
      neutral_return <- residuals(lm_deindustrialize)
      stopifnot(length(neutral_return) == length(df$return))
      df$return <- neutral_return
      regress_result <- lm(return ~ factor_exposure, data = df, ...)
    }
  )

  return(regress_result)
}
```


#### 综合评估结果

```{r factor_test_Uniregression_overall, fig.cap = '因子截面回归评估结果(综合评估)'}


# Condcut factor uniregress test
result_test_uniregression <- factor_test_uniregress(ds_test_uniregression,
  regress_fun = model_univariate_crossection_regression,
  neutralize = "non",
  output_type = "summary",
  factor_field = "factor_name",
  date_field = "date"
)

# Disply test result
knitr::kable(
  summary(result_test_uniregression),
  format = "pandoc",
  align = "c",
  digits = 3,
  caption = " 单因子截面回归评估结果(综合评估)"
)

# Plot test result

plot(result_test_uniregression)
```


#### 行业中性评估结果

```{r factor_test_Uniregression_industry, fig.cap = '因子截面回归评估结果(行业中性评估)'}

# Condcut factor uniregress test
result_test_uniregression_industry <- factor_test_uniregress(ds_test_uniregression,
  regress_fun = model_univariate_crossection_regression,
  neutralize = "industry",
  output_type = "summary",
  factor_field = "factor_name",
  date_field = "date"
)

# Disply test result
knitr::kable(
  summary(result_test_uniregression_industry),
  format = "pandoc",
  align = "c",
  digits = 3,
  caption = " 单因子截面回归评估结果(行业中性评估)"
)

# Plot test result
plot(result_test_uniregression_industry)
```


## 因子信息系数(IC)评估(Factor Test of Information Coefficients)

### 因子评估方法

* **步骤1、计算每期因子与随后实现收益之间的横截面相关性**

  在指定时期内的每个时点$t$，单个因素与其后k期实现收益的横截面相关性：
  $$IC_{t,t+k} = corr(f_{t}, r_{t, t+k})$$
 其中$f_{t}$是在$t$时刻的横截面因素值向量，$r_{t, t+k}$是$t$时刻到$t+k$时刻收益率向量。IC值介于-1与+1之间，正IC值表因素与收益率之间存在正相关，负的IC表示因素与收益之间存在负向关的关系。 获得各横截面上的IC值形成IC序列。
 
  - **综合评估**
  
    不考虑行业因素影响，直接使用规范化处理的因子暴露值来计算相关系数。
  
  - **行业中性评估**
  
    为消除排除行业因素的影响，在因子规范化处理后，在每个截面期上用因子暴露值做因变量对行业进行线性回归，取残差作为因子暴露值的替代。这种做法可以消除因子在行业、板块、市值等方面的偏离。例如，股息率因子较高的个股可能较多分布在电力及公用事业、汽车、商贸零售等行业以及大市值板块，经过因子提纯之后，股息率因子较高的个股就会平均分布在各行业及板块。
 

* **步骤2、对IC序列进行$t$检验**

  对信息系数(IC)序列进行$t$检验，判断因子的平均IC是否显著不为零, 同时统计正值/负值比例，结合IC平值的正负，来观察IC相关性的方向。
  
* **步骤2、评估因子的多时期IC序列均值变化趋势**
  
  由于因子收益实现的时间通常不一样，所以需要对因子随不同时期跨度$k(1~12)$IC均值变化趋势进行比较。针对每个时期跨度$k$, 对应的IC系例均值为:
  $$\overline{IC}=mean(IC_{t,t+k})$$

### 因子评估结果

因子评估结果字段说明：

* factor_name: 因子名称
* obs: 信息系数序列中样本数；
* nas: 信息系数序列中NA数；
* avg: 信息系数序例样本均值；
* med: 信息系数序例样本中数；
* min: 信息系数序例样本最小值；
* max: 信息系数序例样本最大值；
* std：信息系数序例样本标准差；
* skew: 信息系数序例样本偏度；
* kurt: 信息系数序例样本超额峰度；
* pos_pct: 信息系数序列中正值比例；
* neg_pct: 信息系数序列中负值比例；
* odds: 因子收益序列胜率=正值比例/负值比例；
* t.test_t: 对信息系数序列均值非零$t$检验的$t$统计量 绝对值大于2时均值显著不为0；
* t.test_p: 对信息系数序列均值非零$t$检验的$p$概率值, 小于0.05时均值显著不为0
* normal.test_p: 正态分布检验(Shapiro-Wilk)$p$概率值，小于0.05时判定信息系数序列非正态分布。

```{r factor_test_IC_common, cache=FALSE, autodep= TRUE}

# Build test dataset for single period test
ds_test_IC <- stocks_return_period %>%
  dplyr::inner_join(fundamental_normal_factors_lag_period, by = c("date", "stkcd")) %>%
  tidyr::gather(-(date:indcd), key = "factor_name", value = "factor_exposure") %>%
  dplyr::select(date, stkcd, indcd, return, factor_name, factor_exposure)


# Build test dataset for multiperiod test
k_periods <- 12
ds_test_IC_multiperiod <- tibble::tibble(k = 1:k_periods, ds_test_IC = list(0))
for (k in seq_along(ds_test_IC_multiperiod$k)) {

  # Lag factors datase k periods
  factors_lag_k_period <- ts_lag(fundamental_normal_factors_period,
    k = k,
    trim = FALSE,
    key_fields = c("stkcd", "period", "indcd")
  )
  # Combine return and factors
  ds_test_IC <- stocks_return_period %>%
    dplyr::inner_join(factors_lag_k_period, by = c("date", "stkcd")) %>%
    tidyr::gather(-(date:indcd), key = "factor_name", value = "factor_exposure") %>%
    dplyr::select(date, stkcd, indcd, return, factor_name, factor_exposure)

  ds_test_IC_multiperiod$ds_test_IC[[k]] <- ds_test_IC
}

# Method of conducting IC test
model_compute_IC <- function(df,
                             neutralize = c("non", "industry"),
                             ...) {

  # Conduct corr test
  neutralize <- match.arg(neutralize)
  switch(neutralize,
    "non" = {
      # Overall test
      suppressWarnings({
        IC_result <- cor.test(x = df$return, y = df$factor_exposure, ...)
      })
    },
    "industry" = {

      # Remove impact of industry on facgtor exporusre
      lm_deindustrialize <- lm(factor_exposure ~ indcd,
        data = df,
        na.action = na.exclude
      )

      # Use residual to conduct test
      neutral_factor_exposure <- residuals(lm_deindustrialize)
      suppressWarnings({
        IC_result <- cor.test(
          x = df$return,
          y = neutral_factor_exposure, ...
        )
      })
    }
  )

  return(IC_result)
}
```


#### 综合评估结果 

**因子信息系数(IC)单期评估结果如下：**

```{r factor_test_IC_single_period_overall, fig.cap='因子信息系数(IC)单期评估结果(综合评估)'}

# Condcut factor IC test
result_test_IC <- factor_test_IC(ds_test_IC,
  IC_fun = model_compute_IC,
  neutralize = "non",
  method = "spearman",
  output_type = "summary",
  factor_field = "factor_name",
  date_field = "date"
)

# Disply test result
knitr::kable(
  summary(result_test_IC),
  format = "pandoc",
  align = "c",
  digits = 3,
  caption = "单因子信息系数(IC)评估结果(综合评估)"
)

# Plot test result
plot(result_test_IC)
```

**因子信息系数(IC)多期评估结果如下：**

```{r factor_test_IC_multi_period_overall, fig.cap='因子信息系数(IC)多期评估结果(综合评估)'}

# Condcut factor IC test of multiperiods
result_test_IC_multiperiod <- tibble::tibble(
  k = 1:k_periods,
  result_test_IC = list(0)
)
for (k in seq_along(result_test_IC_multiperiod$k)) {
  result_test_IC <- factor_test_IC(ds_test_IC_multiperiod$ds_test_IC[[k]],
    IC_fun = model_compute_IC,
    neutralize = "non",
    method = "spearman",
    output_type = "summary",
    factor_field = "factor_name",
    date_field = "date"
  )

  result_test_IC_multiperiod$result_test_IC[[k]] <- result_test_IC@summary
}

# Reshape result datasets
result_test_IC_multiperiod <- result_test_IC_multiperiod %>%
  tidyr::unnest(result_test_IC) %>%
  dplyr::arrange(factor_name, k)

# Plot tendency of ICs in term of k periods
result_test_IC_multiperiod %>%
  ggplot(aes(x = k)) +
  geom_line(aes(y = avg)) +
  facet_wrap(~factor_name) +
  scale_x_continuous(breaks = seq(1, k_periods, 1)) +
  labs(
    title = "因子IC均值在不同期限变化趋势",
    x = "时期k",
    y = "IC均值"
  ) +
  theme(plot.title = element_text(hjust = 0.5))

# Plot t.test siginificancy of ICs in term of k periods
result_test_IC_multiperiod %>%
  ggplot(aes(x = k)) +
  geom_bar(aes(y = t.test_p), stat = "identity") +
  geom_hline(yintercept = 0.05, color = "red", linetype = "dashed") +
  facet_wrap(~factor_name) +
  scale_x_continuous(breaks = seq(1, k_periods, 1)) +
  labs(
    title = "因子IC均值在不同期限T测试显著性",
    x = "时期k",
    y = "IC序列t检测p值"
  ) +
  theme(plot.title = element_text(hjust = 0.5))
```



#### 行业中性评估结果

**因子信息系数(IC)单期评估结果如下：**

```{r factor_test_IC_single_period_industry, fig.cap = '因子信息系数(IC)单期评估结果(行业中性评估)'}

# Condcut factor IC test
result_test_IC_industry <- factor_test_IC(ds_test_IC,
  IC_fun = model_compute_IC,
  neutralize = "industry",
  method = "spearman",
  output_type = "summary",
  factor_field = "factor_name",
  date_field = "date"
)

# Disply test result
knitr::kable(
  summary(result_test_IC_industry),
  format = "pandoc",
  align = "c",
  digits = 3,
  caption = "单因子信息系数(IC)评估结果(行业中性评估)"
)

# Plot test result
plot(result_test_IC_industry)
```

**因子信息系数(IC)多期评估结果如下：**

```{r factor_test_IC_multi_period_industry, fig.cap='因子信息系数(IC)多期评估结果(行业中性评估)'}

# Condcut factor IC test of multiperiods
result_test_IC_multiperiod <- tibble::tibble(
  k = 1:k_periods,
  result_test_IC = list(0)
)
for (k in seq_along(result_test_IC_multiperiod$k)) {
  result_test_IC <- factor_test_IC(ds_test_IC_multiperiod$ds_test_IC[[k]],
    IC_fun = model_compute_IC,
    neutralize = "industry",
    method = "spearman",
    output_type = "summary",
    factor_field = "factor_name",
    date_field = "date"
  )

  result_test_IC_multiperiod$result_test_IC[[k]] <- result_test_IC@summary
}

# Reshape result datasets
result_test_IC_multiperiod <- result_test_IC_multiperiod %>%
  tidyr::unnest(result_test_IC) %>%
  dplyr::arrange(factor_name, k)

# Plot tendency of ICs in term of k periods
result_test_IC_multiperiod %>%
  ggplot(aes(x = k)) +
  geom_line(aes(y = avg)) +
  facet_wrap(~factor_name) +
  scale_x_continuous(breaks = seq(1, k_periods, 1)) +
  labs(
    title = "因子IC均值在不同期限变化趋势",
    x = "时期k",
    y = "IC均值"
  ) +
  theme(plot.title = element_text(hjust = 0.5))

# Plot t.test siginificancy of ICs in term of k periods
result_test_IC_multiperiod %>%
  ggplot(aes(x = k)) +
  geom_bar(aes(y = t.test_p), stat = "identity") +
  geom_hline(yintercept = 0.05, color = "red", linetype = "dashed") +
  facet_wrap(~factor_name) +
  scale_x_continuous(breaks = seq(1, k_periods, 1)) +
  labs(
    title = "因子IC均值在不同期限T测试显著性",
    x = "时期k",
    y = "IC序列t检测p值"
  ) +
  theme(plot.title = element_text(hjust = 0.5))
```


## 因子组合分类法(Factor Test of Sort Portfolios)

### 因子评估方法

* **步骤1、在截面上按单因子暴露值构建为N种投资组合**

  基本思路：每个时点$t$横截面上，根据单因子在的暴露值对股票进行排序，将股票分为N个投资组合(通常N=5,group_lo,..,group_hi)，计算各组合在评估期的收益序列，并构建"零投资组合"($group\_zero = group\_hi - group\_lo$)。
  
  
  - **综合分类划分法**
   
    不考虑行业对因子效果的影响，直接在全股票汇中不分行业，按因子暴露值进行打分排序，分成N个投资组合，在每个组合中股票按等权或市值进行配比。
  
  - **行业分层划分法**
  
    为减少行业对因子效果的影响，采用行业分层来划分投资组合:将所有个股在各行业内按照因子暴露进行排序，每个行业内分为N个投资组合，然后将各行业的N个组合中相同序号组合结合成一起构后新的组合（共形成N个组合），在每个组合中股票按等权或市值进行配比。
  

* **步骤2、检验零组合与N个投资组合的绩效，判断零投资组合平均收益(因子收益)是否显著不为零**
 
  - 评估因子收益率显著性：零组合的平均收益率即为因子收益率，判断因子的平均收益的是不显著不为零， 同时统计正值/负值比例，结合平均收益率的正负，判断察因子收益的方向。
  
  - 评估各投资组合绩效：年化平均收益率、年化收益率标准差、年化夏普比率。
 


### 因子评估结果

1. 因子评估结果字段说明：

  * factor_name: 因子名称
  * obs: 因子收益序列中样本数；
  * nas: 因子收益序列中NA数；
  * avg: 因子收益序例样本均值；
  * med: 因子收益序例样本中数；
  * min: 因子收益序例样本最小值；
  * min: 因子收益序例样本最大值；
  * std：因子收益序例样本标准差；
  * skew: 因子收益序例样本偏度；
  * kurt: 因子收益序例样本超额峰度；
  * pos_pct: 因子收益序列中正值比例；
  * neg_pct: 因子收益序列中负值比例；
  * odds: 因子收益序列胜率=正值比例/负值比例；
  * t.test_t: 对因子收益序列均值非零$t$检验的$t$统计量 绝对值大于2时均值显著不为0；
  * t.test_p: 对因子收益序列均值非零$t$检验的$p$概率值, 小于0.05时均值显著不为0
  * normal.test_p: 正态分布检验(Shapiro-Wilk)$p$概率值，小于0.05时判定因子收益序列非正态分布。

2. 各分类组合绩效评估结果字段说明

  * Annualized Return：组合的年化收益率；
  * Annualized Standard Deviation：组合的年化收益的标准差；
  * Annualized Sharpe Ratio (Rf=0%)：组合的年化夏普比率。

```{r factor_test_portfolio_sorts_common, cache=FALSE, autodep= TRUE}
# Build test data dataset
ds_test_sort_portfolios <- stocks_return_period %>%
  dplyr::inner_join(fundamental_normal_factors_lag_period, by = c("date", "stkcd")) %>%
  tidyr::gather(-(date:indcd), key = "factor_name", value = "factor_exposure") %>%
  dplyr::select(date, stkcd, indcd, return, factor_name, factor_exposure)


# Method to build sort portfolios
model_sort_portfolios <- function(df, ngroup = 5,
                                  neutralize = c("non", "industry"),
                                  ...) {

  # Build portfolio group by portfolio groups
  neutralize <- match.arg(neutralize)
  switch(neutralize,
    "non" = {
      # Build overal N portfolios
      sort_portfolios <- build_sort_portfolios(
        stocks_list = df$stkcd,
        factor_value_list = df$factor_exposure,
        stocks_weight_list = NULL,
        ngroup = ngroup
      )
    },
    "industry" = {
      # Group data by industry
      df_by_industry <- df %>%
        dplyr::group_by(indcd)

      # Build N portfolios in echa industry
      portfolios_by_industry <- df_by_industry %>%
        dplyr::summarise(groups = list(build_sort_portfolios(
          stocks_list = stkcd,
          factor_value_list = factor_exposure,
          stocks_weight_list = NULL,
          ngroup = ngroup
        )))

      # combine N portfolios in each industry into overal N portolios
      sort_portfolios <- portfolios_by_industry %>%
        tidyr::unnest(groups) %>%
        dplyr::arrange(portfolio_group, stkcd) %>%
        dplyr::select(-indcd)
    }
  )

  return(sort_portfolios)
}
```


#### 综合评估结果

   
```{r factor_test_portfolio_sorts_overall, fig.cap = '因子组合分类评估结果(综合评估)'}


# Condcut portfolio sorts test
result_test_sort_portfolios <- factor_test_sort_portfolios(ds_test_sort_portfolios,
  sort_portfolios_fun = model_sort_portfolios,
  ngroup = 5,
  neutralize = "non",
  output_type = "summary",
  factor_field = "factor_name",
  date_field = "date",
  stkcd_field = "stkcd",
  return_field = "return"
)


# Disply test result

# sumary of test
knitr::kable(
  summary(result_test_sort_portfolios),
  format = "pandoc",
  align = "c",
  digits = 3,
  caption = "投资组合分类法评估结果(综合评估)"
)

# summary of portfolio performance
knitr::kable(
  result_test_sort_portfolios@portfolios_summary,
  format = "pandoc",
  align = "c",
  digits = 3,
  caption = "各分类组合绩效评估结果(综合评估)"
)

# Plot test result
plot(result_test_sort_portfolios)
```

#### 行业中性评估结果


```{r factor_test_portfolio_sorts_industry, fig.cap = '因子组合分类评估结果(行业中性评估)'}


# Condcut portfolio sorts test
result_test_sort_portfolios_industry <- factor_test_sort_portfolios(ds_test_sort_portfolios,
  sort_portfolios_fun = model_sort_portfolios,
  ngroup = 5,
  neutralize = "industry",
  output_type = "summary",
  factor_field = "factor_name",
  date_field = "date",
  stkcd_field = "stkcd",
  return_field = "return"
)


# Disply test result

# sumary of test
knitr::kable(
  summary(result_test_sort_portfolios_industry),
  format = "pandoc",
  align = "c",
  digits = 3,
  caption = "投资组合分类法评估结果(行业中性)"
)

# summary of portfolio performance
knitr::kable(
  result_test_sort_portfolios_industry@portfolios_summary,
  format = "pandoc",
  align = "c",
  digits = 3,
  caption = "各分类组合绩效总览(行业中性)"
)

# Plot test result
plot(result_test_sort_portfolios_industry)
```

# 评估汇总( Evaluation Summary)

## 评估汇总方法

汇总各项评估结果，评估因子的统计显著性和方向性：

* **统计显著性**

    通过因子评估结果序列进行$t$检验，当概率p值小于0.05时，说时序列均值显著不为0，即因子是统计显著的。

* **方向性**

    当因子序列均值统计显著不为0时，可判断因子对股票回报的影响：

 - 序列均值大于0时，因子与股票为正相关；
 
   当正相关时，如果胜率(odds)大于1时，则相关性较强，否则较弱。
   
 - 序列均值小于0时，因子与股票为负相关；
 
   当负相关时，如果胜率(odds)小于1时，则相关性较强，否则较弱。


```{r evalute_test_result_common}

# Evalue test result to find petential significant factors
evalute_test_result <- function(summary_test_result,
                                signif_level = 0.05) {

  # Evaluate all factors
  eval_result_all <- summary_test_result %>%
    dplyr::arrange(factor_name, test) %>%
    dplyr::mutate(
      significant = {
        ifelse(t.test_p <= signif_level, "yes", "no")
      },
      direction = {
        ifelse(avg > 0, "positive",
          ifelse(avg < 0, "negtive", "NA")
        )
      },
      effect = {
        ifelse(((direction == "positive") && (odds > 1))
        || ((direction == "negtive") && (odds < 1)),
        "strong", "weak"
        )
      }
    ) %>%
    dplyr::select(
      factor_name, test, t.test_p, significant,
      avg, odds, direction, effect
    )

  # Get potential significant factors
  potential_factors <- eval_result_all %>%
    dplyr::filter(significant == "yes") %>%
    dplyr::select(factor_name)
  potential_factors <- unique(as.vector(potential_factors$factor_name))

  # Potential factor evaluation results
  eval_result_potentials <- eval_result_all %>%
    dplyr::filter(factor_name %in% potential_factors) %>%
    dplyr::select(test, factor_name, t.test_p) %>%
    dplyr::group_by(factor_name) %>%
    dplyr::mutate(significant = ifelse(any(t.test_p <= signif_level),
      "yes", "no"
    )) %>%
    tidyr::spread(key = test, value = t.test_p)

  # Build results
  eval_result <- list(
    potential_factors = potential_factors,
    potential_result = eval_result_potentials,
    all_result = eval_result_all
  )

  return(eval_result)
}
```


## 评估汇总结果

### 综合评估结果

```{r evaluate_test_result_overall}

# Integrate results for evaluation
summary_test_uniregression <- result_test_uniregression@summary %>%
  dplyr::mutate(test = "uniregression_test") %>%
  dplyr::select(test, dplyr::everything())

summary_test_IC <- result_test_IC@summary %>%
  dplyr::mutate(test = "IC_test") %>%
  dplyr::select(test, dplyr::everything())

summary_test_sort_portfolios <- result_test_sort_portfolios@summary %>%
  dplyr::mutate(test = "sort_portfolios_test") %>%
  dplyr::select(test, dplyr::everything())

summary_all_test <- summary_test_uniregression %>%
  dplyr::bind_rows(summary_test_IC) %>%
  dplyr::bind_rows(summary_test_sort_portfolios)

# Evalue all test results
eval_result <- evalute_test_result(summary_all_test, signif_level = 0.05)

# Print evluation result of all factors
knitr::kable(
  eval_result$all_result,
  format = "pandoc",
  align = "c",
  digits = 3,
  longtable = TRUE,
  caption = "Evaluation of factors(Overall Test)"
)
```

**潜在有效因子：**

```{r potential_factors_overall, results='asis'}

# Print potential factors
if (length(eval_result$potential_factors) > 0) {
  potential_facotrs_list <- eval_result$potential_factors
} else {
  potential_facotrs_list <- "NA"
}
cat(potential_facotrs_list)


# Print evaluation result of potential factors
if (nrow(eval_result$potential_result) > 0) {
  knitr::kable(
    eval_result$potential_result,
    format = "pandoc",
    align = "c",
    digits = 3,
    caption = "Potential Effective Factors(Overall Test)"
  )
}
```


### 行业中性评估结果

```{r evaluate_test_result_industry}

# Integrate results for evaluation
summary_test_uniregression <- result_test_uniregression_industry@summary %>%
  dplyr::mutate(test = "uniregression_test") %>%
  dplyr::select(test, dplyr::everything())

summary_test_IC <- result_test_IC_industry@summary %>%
  dplyr::mutate(test = "IC_test") %>%
  dplyr::select(test, dplyr::everything())

summary_test_sort_portfolios <- result_test_sort_portfolios_industry@summary %>%
  dplyr::mutate(test = "sort_portfolios_test") %>%
  dplyr::select(test, dplyr::everything())

summary_all_test <- summary_test_uniregression %>%
  dplyr::bind_rows(summary_test_IC) %>%
  dplyr::bind_rows(summary_test_sort_portfolios)

# Evalue all test results
eval_result_industry <- evalute_test_result(summary_all_test, signif_level = 0.05)

# Print evluation result of all factors
knitr::kable(
  eval_result_industry$all_result,
  format = "pandoc",
  align = "c",
  digits = 3,
  longtable = TRUE,
  caption = "Evaluation of factors(Neutral-Industry Test)"
)
```

**潜在有效因子：**

```{r potential_factors_industry, results='asis'}
# Print potential factors
if (length(eval_result_industry$potential_factors) > 0) {
  potential_facotrs_list <- eval_result_industry$potential_factors
} else {
  potential_facotrs_list <- "NA"
}
cat(potential_facotrs_list)

# Print evaluation result of potential factors
if (nrow(eval_result_industry$potential_result) > 0) {
  knitr::kable(
    eval_result$potential_result,
    format = "pandoc",
    align = "c",
    digits = 3,
    caption = "Potential Effective Factors(Neutral Industry Test)"
  )
}
```


