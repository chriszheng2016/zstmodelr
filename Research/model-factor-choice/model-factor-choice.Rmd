---
title: "R Notebook"
params:
  backtest_start_date:
    label: 'backtest start date:'
    value: '2016-01-01'
  backtest_end_date:
    label: 'backtest end date:'
    value: '2017-12-31'
  debug_mode: yes
  factors_list:
    choices: [GPM, ROCE, PE, PB, CUR, QR]
    input: select
    label: factors list
    multiple: yes
    value: DE, FL, TDR
  tmpfile_fundamental_factors: tempdata/fundamental_factors.rds
  tmpfile_fundamental_normal_factors: tempdata/fundamental_normal_factors.rds
  tmpfile_fundamental_normal_factors_period: tempdata/fundamental_normal_factors_period.rds
  tmpfile_fundamental_normal_factors_pre_period: tempdata/fundamental_normal_factors_pre_period.rds
  tmpfile_stocks_return: tempdata/stocks_return.rds
  tmpfile_stocks_return_period: tempdata/stocks_return_period.rds
output:
  rticles::ctex:
    fig_caption: yes
    number_sections: yes
    toc: yes
  word_document:
    toc: yes
  html_document:
    fig_caption: yes
    number_sections: yes
    toc: yes
  html_notebook:
    number_sections: yes
    toc: yes
documentclass: ctexart
classoption: "hyperref,"
---

研究股票的因素模型


```{r setup, include=FALSE  }

library(fPortfolio)
library(PerformanceAnalytics)
library(tidyverse)
library(lubridate)
library(stringr)
library(shiny)
library(zstmodelr)


# Set global options for knitr 
knitr::opts_chunk$set(
comment = "#>",
echo = FALSE,
warning = FALSE,
message = FALSE,
collapse = TRUE
)

options(tibble.print_min = 10L, tibble.print_max = 20L)

# options(digits = 3)

```


# 数据准备

## Set Study Params (设置研究参数)
```{r set_params}
# Set params of study

# fundamental_factors_list <- c("GPM", "ROCE", "PE", "PB", "CUR", "QR")
fundamental_factors_list <- params$factors_list

# period of backtest
start_date <- params$backtest_start_date
end_date <- params$backtest_end_date

```
* __测试因子:__ `r params$factors_list`

* __回测期间:__ `r params$backtest_start_date` ~ `r params$backtest_end_date`


## Load facotrs data (加载因子数据)
```{r fetch_factors_data}

if (!params$debug_mode) {
  # Open gta stock databse
  stock_db <- stock_db(gta_db, "GTA_SQLData")
  open_stock_db(stock_db)
  
  # Initate the stock database
  invisible(init_stock_db(stock_db))
  
  # Get fundamental indicators
  fundamental_factors <- get_factor_indicator(stock_db, 
                                  factor_list = fundamental_factors_list)
  
  # Get stocks return
  stocks_return <- get_stock_return(stock_db, 
                                    stock_cd_list = NULL, 
                                    period_type = "monthly", 
                                    return_type = "simple",
                                    use_stock_name = FALSE,
                                    output_type = "tibble")
  # Save temp file for debug
  saveRDS(fundamental_factors, file = params$tmpfile_fundamental_factors)
  saveRDS(stocks_return, file = params$tmpfile_stocks_return)
  
} else {
  
  # Use temp file to debug
  fundamental_factors <- readRDS(params$tmpfile_fundamental_factors)
  stocks_return <- readRDS(params$tmpfile_stocks_return)
}

```


## 因子数据规范化(Factors Normalization)

```{r factors_Normalization }

if (!params$debug_mode) {

  # Normalize the factor indicators
  fundamental_normal_factors <- fundamental_factors %>%
  dplyr::filter( date >= start_date & date <= end_date ) %>%
  normalize_factors( group_by = c("date"), 
                     clean_extremes_method = "sigma",
                     standard_method = "normal")
   
  # Resample factors by specified frequency
  fundamental_normal_factors_period <- fundamental_normal_factors %>%
    ts_resample( by_group = "stkcd", freq_rule = "month", 
                     fillna_method = "ffill", agg_method = mean)
  
  # Resample return by specified frequency
  stocks_return_period <- stocks_return %>%
    dplyr::filter( date >= start_date & date <= end_date ) %>%
    ts_resample( by_group = "stkcd", freq_rule = "month", 
                     fillna_method = "ffill", 
                     agg_method = function(x) prod(1 + x, na.rm = TRUE) - 1)
  
  # Lag factors to avoid peeking ahead bias                                                
  fundamental_normal_factors_pre_period <- ts_lag(
                                          fundamental_normal_factors_period,
                                          k = 1,
                                          trim = TRUE,
                                          by_group = "stkcd")  
  
  # Save temp file for debug
  saveRDS(fundamental_normal_factors, 
          file = params$tmpfile_fundamental_normal_factors)
  saveRDS(fundamental_normal_factors_period, 
          file = params$tmpfile_fundamental_normal_factors_period)
  saveRDS(stocks_return_period, 
          file = params$tmpfile_stocks_return_period)
  saveRDS(fundamental_normal_factors_pre_period, 
          file = params$tmpfile_fundamental_normal_factors_pre_period)
  
} else {
  
  # Use temp file to debug
  fundamental_normal_factors <- readRDS(params$tmpfile_fundamental_normal_factors)
  fundamental_normal_factors_period <- readRDS(params$tmpfile_fundamental_normal_factors_period)
  stocks_return_period <- readRDS(params$tmpfile_stocks_return_period)
  fundamental_normal_factors_pre_period <- readRDS(params$tmpfile_fundamental_normal_factors_pre_period)
  
}

                                   

```



# Uinivariate Factors Test(因子筛选与检测)

## Factor Distribution Exploration(因子分布状况)

```{r factor_test_summarize_dataset}

# summarize facgtor
summary_fundamental_normal_factors <- fundamental_normal_factors %>%
     tidyr::gather(key = "factor_name", value = "factor_exposure", fundamental_factors_list) %>%
     dplyr::group_by(factor_name, date) %>%
     dplyr::summarise_at("factor_exposure", 
                          funs( NAs = sum(is.na(.)),
                                mean,
                                sd,
                                median,
                                mad,
                                min,
                                Q1 = quantile(., 0.25),
                                Q3 = quantile(., 0.75),
                                max,
                                skewness,
                                kurtosis
                              ),
                              na.rm = TRUE) %>%
     dplyr::select(-date) %>%
     dplyr::group_by(factor_name) %>%
     dplyr::summarise_all(mean)


knitr::kable(
  summary_fundamental_normal_factors,
  format = "pandoc",
  align = "c",
  digits = 3,
  caption = "因子分布情况总览"
)

```


## Pooling Univariate Regression Test(单因子池回归)
```{r factor_test_Uniregression_pooling}

# Build test data dataset
ds_test_uniregression_pooling <- stocks_return_period %>%
    dplyr::inner_join(fundamental_normal_factors_pre_period, by = c("date", "stkcd")) %>%
    tidyr::gather(-(date:indcd), key = "factor_name", value = "factor_exposure") %>%
    dplyr::select(date, stkcd, indcd, return , factor_name, factor_exposure)

# Model of conducting univariate regression test
model_univariate_regression_pooling <- function(df) {
  lm(return ~ factor_exposure, data = df)
}

# Condcut factor uniregress test
result_test_uniregression_pooling <- factor_test_uniregress(ds_test_uniregression_pooling,
                                                regress_method = "pooling",                  
                                                regress_fun = model_univariate_regression_pooling,
                                                factor_field = "factor_name",
                                                output_type = "summary",
                                                date_field = "date")
                               
# Disply test result
# summary(result_test_uniregression_pooling)

knitr::kable(
   summary(result_test_uniregression_pooling),
   format = "pandoc",
   align = "c",
   digits = 3,
   caption = "Uniregression Pooling Factor Test"
)


```


## Barra Univarate Reggression Test(Barra单因子截面回归)

因子测试内容：

* **步骤1、单因子回归确定每个因子每期的因子收益**

* **步骤2、因子收益率序列检验**

  - **t值绝对值序列的均值**：
      对于每一期的截面回归，都可以得到一个因子收益率$\tilde{f^{t}_{k}}$的值。对于$\tilde{f^{t}_{k}}$值序列，首先取绝对值$|t|$，然后计算$|t|$的均值，$t$是判断因子是否为有效因子的重要指标，之所以要取绝对值，是因为只要t值显著不等于0，即可以认为在当期因子和收益率存在明显的相关性。但是这种相关性有的时候为正，有的时候为负，如果不取绝对值，则很多正负抵消，会低估因子的有效性。
  - **t值经对值充列大于2的比例**：检验$|t|>2$的比例主要是为了保证$|t|$平均值的稳定性，避免出现少数数值特别大的样本值拉高均值；
  - **因子收益率$\tilde{f^{t}_{k}}$序列t值检验**：对于每一期的截面回归，都可以得到一个因子收益率$\tilde{f^{t}_{k}}$，对于$\tilde{f^{t}_{k}}$序列同样需要进行检验，以观察因子收益率序列的方向一致性。




测试结果字段说明：

* factor_name: 因子名称
* r.squared: 
* f_pvalue:
* beta_t_abs_mean:
* beta_t_sig_ratio:
* beta_t_mean:
* beta_t_sd:
* beta_t_mean_std_ratio:
* factor_return:
* factor_return_tvalue:
* factor_return_pvalue:


```{r factor_test_Uniregression_barra}

# Build test data dataset
ds_test_uniregression_barra <- stocks_return_period %>%
    dplyr::inner_join(fundamental_normal_factors_pre_period, by = c("date", "stkcd")) %>%
    tidyr::gather(-(date:indcd), key = "factor_name", value = "factor_exposure") %>%
    dplyr::select(date, stkcd, indcd, return , factor_name, factor_exposure)


# Model of conducting univariate regression test
model_univariate_regression_barra <- function(df, ...) {
  lm(return ~ factor_exposure, data = df, ...)
}

# Condcut factor uniregress test
result_test_uniregression_barra <- factor_test_uniregress( ds_test_uniregression_barra,
                                                regress_method = "cross_section",                  
                                                regress_fun = model_univariate_regression_barra,
                                                output_type = "summary",
                                                factor_field = "factor_name",
                                                date_field = "date")

# Disply test result
# summary(result_test_uniregression_barra)
knitr::kable(
   summary(result_test_uniregression_barra),
   format = "pandoc",
   align = "c",
   digits = 3,
   caption = "Uniregression Barra Factor Test"
)

# Plot test result                               
plot(result_test_uniregression_barra)

```




## Information Coefficients Test（IC值评估）
```{r factor_test_IC}

# Build test data dataset
ds_test_IC <- stocks_return_period %>%
    dplyr::inner_join(fundamental_normal_factors_pre_period, by = c("date", "stkcd")) %>%
    tidyr::gather(-(date:indcd), key = "factor_name", value = "factor_exposure") %>%
    dplyr::select(date, stkcd, indcd, return , factor_name, factor_exposure)


# Method of conducting IC test
Model_compute_IC <- function(df, ...) {
  cor.test(x = df$return, y = df$factor_exposure, ... )
}

# Condcut factor IC test
result_test_IC <- factor_test_IC( ds_test_IC,
                                  IC_fun = Model_compute_IC,
                                  method = "pearson",
                                  output_type = "summary",
                                  factor_field = "factor_name",
                                  date_field = "date")

# Disply test result
# summary(result_test_IC)
knitr::kable(
   summary(result_test_IC),
   format = "pandoc",
   align = "c",
   digits = 3,
   caption = "IC Factor Test"
)

```

## Factor Sort Portfolios Test(因子组合分类法)
```{r factor_test_portfolio_sorts}

# Build test data dataset
ds_test_sort_portfolios <- stocks_return_period %>%
    dplyr::inner_join(fundamental_normal_factors_pre_period, by = c("date", "stkcd")) %>%
    tidyr::gather(-(date:indcd), key = "factor_name", value = "factor_exposure") %>%
    dplyr::select(date, stkcd, indcd, return , factor_name, factor_exposure)


# Method to build sort portfolios
model_sort_portfolios <- function(df, ...) {
  
  # build portfolio group by portfolio groups
  sort_portfolios <- build_sort_portfolios(stocks_list = df$stkcd,
                                           factor_value_list = df$factor_exposure,
                                           ngroup = 5,
                                           first_group_index = 1,
                                           factor_group_order = "asc" )
  return(sort_portfolios)
}

# Condcut portfolio sorts test
result_sort_portfolios <- factor_test_sort_portfolios(ds_test_sort_portfolios,
                                  sort_portfolios_fun = model_sort_portfolios,
                                  output_type = "summary",
                                  factor_field = "factor_name",
                                  date_field = "date",
                                  stkcd_field = "stkcd",
                                  return_field = "return")


# Disply test result
# summary(result_sort_portfolios)
knitr::kable(
   summary(result_sort_portfolios),
   format = "pandoc",
   align = "c",
   digits = 3,
   caption = "Sort Portfolios Factor Test"
)

# Plot test result
plot(result_sort_portfolios)

```

